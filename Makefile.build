################################################################################
# This is the Makefile that is used to actually build your code. When you run  #
# "make" in the root directory for this project, a "build" directory gets      #
# created and this file is added there as the Makefile. Parts of this Makefile #
# are derived from one generated by the automake utility. Other parts were     #
# derived from the Pintos OS source code Makefiles.                            #
################################################################################

# Since this file gets copied into the build directory, we will
# need to do ../ to get back to the source code directory

SRCDIR = ..

# "all" is a special command directive.  If you run "make" from
# the command line, it will actually invoke "make all".  This, in
# turn, will start a chain reaction that causes the objects to be
# compiled, then linked into an executable at the end. To be
# specific, "make all" depends on completing the "all-prog"
# directive, which is defined below. As you can see there, "all-prog"
# depends on $(PROGRAMS), which is an alias for $(bin_PROGRAMS),
# which is the last directive in this file. You can see that one
# depends on $(OBJECTS), which are the individually compiled object
# files (one is generated for each .c source file). Once all of
# those are compiled, we can link them together to build our
# program.
all: all-prog

include ../Make.config
include ../tests/Make.tests
include ../Make.src

# Specify the name of your executable program here. Notice that the
# $(EXEEXT) is specified in Make.config as appropriate for your
# platform. If this were a Windows machine, it would be .exe
# Note that it is important to have no spaces or punctuation between
# your program name $(EXENAME) and the $(EXEEXT)
bin_PROGRAMS = $(EXENAME)$(EXEEXT)

# If the project had multiple subdirectories (instead of just the
# single "project" subdirectory we are using), SOURCES would be the
# concatenation of all the files named in the source code listing
# above. Objects would be the same, but replace .c with .o for each
# file.
SOURCES = $(foreach dir,$(SRC_SUBDIRS),$($(dir)_SRC))
OBJECTS = $(patsubst %.c,%.o,$(SOURCES))
PROGRAMS = $(bin_PROGRAMS)

# To build the testsuite, we swap out the main.c with testsuite.c.
# We also compile without the -Werror flag to ensure it runs.
TOBJNOMAIN = $(patsubst src/main/main.%,,$(OBJECTS))
TOBJECTS = $(patsubst src/main/demo.%,,$(TOBJNOMAIN))
TCOMPILE = $(patsubst -Werror,,$(COMPILE))
TPROGRAM = $(patsubst $(EXENAME),$(TEST_EXE),$(PROGRAMS))

all-prog: Makefile $(PROGRAMS)

# Executing "make clean" will delete the executable and all object
# files.  This creates a nice, clean software package ready for
# compilation.
clean::
	-test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS)
	-test -z "$(OBJECTS)" || rm -f $(OBJECTS)
	-test -z "$(TPROGRAM)" || rm -f $(TPROGRAM)
	-test -z "$(TOBJECTS)" || rm -f $(TOBJECTS)
	-test -z "$(TOBJECT)" || rm -f $(TOBJECT)

Makefile: $(SRCDIR)/Makefile.build
	cp $< $@

$(TPROGRAM): $(TOBJECTS) $(TEST_SUBDIRS)
	@rm -f $@
	$(TCOMPILE) -c $(SRCDIR)/$(TEST_SRC) -o $(TEST_OBJECT)
	$(LINK) $(TOBJECTS) $(SRC_OBJECTS) $(TEST_OBJECT) -lcheck -lpthread -lm  -lsubunit -lrt
	./$@ > $@.output 2>$@.errors

# Specify how to build the final executable. This depends on first
# building all the objects. Once they are all compiled, we link
# them together into a single executable.
$(bin_PROGRAMS): $(OBJECTS) $(SRC_OBJECTS)
	@rm -f $(bin_PROGRAMS)
	$(LINK) $(OBJECTS) $(SRC_OBJECTS)

testsuite: $(TEST_SRC) $(TEST_SUITES) $(bin_PROGRAMS) -lsubunit -lrt
