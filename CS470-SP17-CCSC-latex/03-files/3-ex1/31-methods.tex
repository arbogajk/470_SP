\documentclass[main.tex]{subfiles}

\begin{document}

\indent Utilizing a single Dell PowerEdge R430 with a Xeon E5-2630v3 processor with 8 Cores, 2.4Ghz, Hyper Threaded, we approached this problem using OpenMP to take advantage of the API's parallel for loop feature. Specifically, we identified 3 regions of the code where parallelism could exist. All of our experiments and testing where conducted on the Dell PowerEdge, using the maximum number of shares and threshold the original program was capable of generating, which was 255 key shares.  For our test data sets, we used text files containing 540, 1080, 2160, 4320, and 8640 characters.  We also used a 4096 bit RSA private key, containing 3,272 characters including the RSA header details as an input file into the program.  Our weak scaling test, consist of doubling the character count of the input file, while doubling the thread count.

\indent Our focus at first was studying the functions that dealt with generating the key shares. We identified two functions in the implementation that allowed for substantial decreases in time for computing the keys.  Firstly, we were able to parallelize the for loop that generates the random coefficients used in the polynomial function.  Secondly, we were able to parallelize the for loop that handles computing the key shares.  By leaving the key joining function untouched, we were able to verify the correctness of our parallel results, by the fact that the key joining function could reassemble the keys into the original text file that was input.
\indent After, implementing parallelism in the key generation stage of Shamir's algorithm, we switched our focus to implementing parallelism with the key joining function.  The challenge with parallelizing the key joining stage of Shamir's secret sharing is correctly identifying variable scope and critical regions. The most important region to consider, is when each thread updates the secret after computing the Lagrange Interpolating Polynomials.  Access to this region has to be synchronized. By correctly identifying these, we were able to parallelize the for loop that computes the Lagrange Interpolating Polynomial of the function used to generate the keys.  




\end{document}
